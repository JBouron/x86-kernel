#include <test.h>

extern void switch_to_proc_test_prog(void);

// Test switch_to_proc(). Disabled for now as there is no way to gracefully come
// back to the kernel.
__attribute__((unused)) static bool switch_to_proc_test(void) {
    struct proc * const proc = create_proc();

    void * code_frame = alloc_frame();
    uint8_t * const code = paging_map_frames_above(0x0, &code_frame, 1, VM_WRITE);
    extern uint8_t switch_to_proc_test_prog_start;
    extern uint8_t switch_to_proc_test_prog_end;
    size_t const code_size =
        &switch_to_proc_test_prog_end - &switch_to_proc_test_prog_start;
    memcpy(code, switch_to_proc_test_prog, code_size);

    uint32_t const flags = VM_USER | VM_NON_GLOBAL;
    void * const eip = paging_map_frames_above_in(proc->addr_space, 0x0, &code_frame, 1, flags);


    proc->registers_save.eip = (reg_t)eip;
    switch_to_proc(proc);
    return true;
}

static bool get_stack_bottom_test(void) {
    void const * const stack_top = 0x0;
    uint32_t const stack_size = 1;
    TEST_ASSERT(get_stack_bottom(stack_top, stack_size) == (void*)0xFFC);
    return true;
}

static bool create_proc_test(void) {
    struct proc * const proc = create_proc();

    // Check that registers are initialized correctly.
    TEST_ASSERT(proc->registers_save.edi == 0);
    TEST_ASSERT(proc->registers_save.esi == 0);
    TEST_ASSERT(proc->registers_save.ebp == (reg_t)proc->stack_bottom);
    TEST_ASSERT(proc->registers_save.ebx == 0);
    TEST_ASSERT(proc->registers_save.edx == 0);
    TEST_ASSERT(proc->registers_save.ecx == 0);
    TEST_ASSERT(proc->registers_save.eax == 0);
    TEST_ASSERT(proc->registers_save.eip == 0);
    TEST_ASSERT(proc->registers_save.eflags == 1 << 9);
    TEST_ASSERT(proc->registers_save.esp == (reg_t)(proc->stack_bottom));

    return true;
}

void proc_test(void) {
    TEST_FWK_RUN(get_stack_bottom_test);
    TEST_FWK_RUN(create_proc_test);
    // Disabled. See comment on switch_to_proc_test().
    //TEST_FWK_RUN(switch_to_proc_test);
}
