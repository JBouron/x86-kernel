#include <test.h>
#include <acpi.h>
#include <ipm.h>
#include <proc_test_helpers.h>

static bool get_stack_bottom_test(void) {
    void const * const stack_top = 0x0;
    uint32_t const stack_size = 1;
    TEST_ASSERT(get_stack_bottom(stack_top, stack_size) == (void*)0xFFC);
    return true;
}

static bool create_proc_test(void) {
    struct proc * const proc = create_proc();

    // Check that registers are initialized correctly.
    TEST_ASSERT(proc->registers.edi == 0);
    TEST_ASSERT(proc->registers.esi == 0);
    TEST_ASSERT(proc->registers.ebp == (reg_t)proc->user_stack.bottom);
    TEST_ASSERT(proc->registers.ebx == 0);
    TEST_ASSERT(proc->registers.edx == 0);
    TEST_ASSERT(proc->registers.ecx == 0);
    TEST_ASSERT(proc->registers.eax == 0);
    TEST_ASSERT(proc->registers.eip == 0);
    TEST_ASSERT(proc->registers.eflags == 1 << 9);
    TEST_ASSERT(proc->registers.esp == (reg_t)(proc->user_stack.bottom));

    // No program has been loaded in this process yet.
    TEST_ASSERT(proc->state_flags == PROC_WAITING_EIP);

    delete_proc(proc);
    return true;
}

static bool create_kproc_test(void) {
    void * const func = (void *)0xDEADBEEF;
    void * const arg = (void *)0xABCDEF;
    struct proc * const proc = create_kproc(func, arg);

    // Check that registers are initialized correctly.
    TEST_ASSERT(proc->registers.edi == 0);
    TEST_ASSERT(proc->registers.esi == 0);
    TEST_ASSERT(proc->registers.ebp == (reg_t)proc->kernel_stack.bottom);
    TEST_ASSERT(proc->registers.ebx == 0);
    TEST_ASSERT(proc->registers.edx == 0);
    TEST_ASSERT(proc->registers.ecx == 0);
    TEST_ASSERT(proc->registers.eax == 0);
    TEST_ASSERT(proc->registers.eip == (reg_t)func);
    TEST_ASSERT(proc->registers.eflags == 1 << 9);

    // Check that current stack frame contains correct values.
    TEST_ASSERT(proc->registers.esp == (reg_t)(proc->kernel_stack.bottom - 8));
    uint32_t const * const esp = (uint32_t const *)proc->registers.esp;
    TEST_ASSERT(esp[0] == (uint32_t)&catch_kstack_underflow);
    TEST_ASSERT(esp[1] == (uint32_t)arg);

    TEST_ASSERT(proc->state_flags == PROC_RUNNABLE);

    delete_proc(proc);
    return true;
}

// Tries to execute a privileged instruction.
extern void privileged_instr_in_ring3_code(void);

static bool volatile privileged_instr_in_ring3_gp_raised = false;
static reg_t privileged_instr_in_ring3_expected_eip = 0;
static void privileged_instr_in_ring3_gp_handler(
    struct interrupt_frame const * const frame) {

    LOG("General protection fault recieved on cpu %u\n", cpu_id());

    // Check that the EIP points to the correct instruction and that the
    // original CS was user code segment.
    privileged_instr_in_ring3_gp_raised =
        frame->registers->eip == privileged_instr_in_ring3_expected_eip &&
        frame->registers->cs == user_code_seg_sel().value;

    // Wait for the cpu running the test to re-init this cpu.
    lock_up();
}

static bool privileged_instr_in_ring3_test(void) {
    struct proc * const proc = create_proc();

    extern uint8_t privileged_instr_in_ring3_code_start;
    extern uint8_t privileged_instr_in_ring3_code_end;
    size_t const len = &privileged_instr_in_ring3_code_end -
        &privileged_instr_in_ring3_code_start;
    void const * const code = privileged_instr_in_ring3_code;

    copy_code_to_proc(proc, code, len);
    // The very first instruction should be the one raising the #GP.
    privileged_instr_in_ring3_expected_eip = proc->registers.eip;

    // Vector for a General Protection Fault.
    uint8_t const v = 13;
    interrupt_register_global_callback(v, privileged_instr_in_ring3_gp_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (cpu_id() + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, proc, false);

    // The process running in ring 3 will try to execute the cli instruction
    // which is a privileged instruction. Therefore a general protection fault
    // should be raise. The privileged_instr_in_ring3_gp_handler() will set the
    // privileged_instr_in_ring3_gp_raised bit to true when that happens.
    while (!privileged_instr_in_ring3_gp_raised) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();

    interrupt_delete_global_callback(v);
    delete_proc(proc);
    return true;
}

extern void kernel_access_from_ring3_code(void);

static reg_t kernel_access_from_ring3_expected_eip = 0;
uint32_t kernel_access_from_ring3_kernel_var = 0xDEADBEEF;
static bool kernel_access_from_ring3_pg_ok = false;

static void kernel_access_from_ring3_pg_handler(
    struct interrupt_frame const * const frame) {
    LOG("Page fault from ring 3\n");
    LOG("Error Code = %x\n", frame->error_code);
    bool success = true;
    success &= frame->registers->cs == user_code_seg_sel().value;
    success &= frame->registers->eip == kernel_access_from_ring3_expected_eip;
    success &= cpu_read_cr2() == &kernel_access_from_ring3_kernel_var;
    // The error code should have the following bits set: User-mode access,
    // Write, Page-level protection violation.
    success &= frame->error_code == ((1 << 2) | (1 << 1) | 1);
    kernel_access_from_ring3_pg_ok = success;

    lock_up();
}

// Test that a process running in ring 3 gets a page fault when trying to access
// kernel data.
static bool kernel_access_from_ring3_test(void) {
    struct proc * const proc = create_proc();

    extern uint8_t kernel_access_from_ring3_code_start;
    extern uint8_t kernel_access_from_ring3_code_end;
    size_t const len = &kernel_access_from_ring3_code_end -
        &kernel_access_from_ring3_code_start;
    void const * const code = kernel_access_from_ring3_code;

    copy_code_to_proc(proc, code, len);

    kernel_access_from_ring3_expected_eip = proc->registers.eip;

    interrupt_register_global_callback(14, kernel_access_from_ring3_pg_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (cpu_id() + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, proc, false);

    while (!kernel_access_from_ring3_pg_ok) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();
    interrupt_delete_global_callback(14);
    delete_proc(proc);
    return true;
}

// This percpu variable is used by the kernel process to make sure that it can
// access the percpu variables.
DECLARE_PER_CPU(uint64_t, kernel_process_test_data);
static uint64_t kernel_process_test_data_expected = 0;
static uint16_t kernel_process_test_expected_gs = 0;
static bool volatile kernel_process_test_success = false;
static void * kernel_process_expected_arg = NULL;

static void kernel_process_code(void * arg) {
    LOG("[%u] Kernel process is running kernel code.\n", cpu_id());
    bool success = true;

    // Check that the correct arg was passed onto the stack.
    success &= arg == kernel_process_expected_arg;

    // Make sure we are in ring 0.
    success &= cpu_read_cs().value == kernel_code_selector().value;
    success &= cpu_read_ds().value == kernel_data_selector().value;
    success &= cpu_read_fs().value == kernel_data_selector().value;
    success &= cpu_read_es().value == kernel_data_selector().value;
    success &= cpu_read_ss().value == kernel_data_selector().value;
    success &= cpu_read_gs().value == kernel_process_test_expected_gs;

    // Try to access the cpu vars.
    success &= this_cpu_var(kernel_process_test_data) ==
        kernel_process_test_data_expected;

    // Try to execute some privileged instructions.
    cpu_set_interrupt_flag(false);
    cpu_set_interrupt_flag(true);

    kernel_process_test_success = success;

    // Wait to be reset.
    lock_up();
}

static void remote_read_gs(void * arg) {
    uint16_t const expected_gs = cpu_read_gs().value;
    LOG("[%u] Expected GS = %x\n", cpu_id(), expected_gs);
    *(uint16_t*)arg = expected_gs;
}

static bool kernel_process_test(void) {
    void * const arg = (void*)0xDEADBABE;
    kernel_process_expected_arg = arg;

    struct proc * const kproc = create_kproc(kernel_process_code, arg);

    uint64_t const rand = read_tsc();
    kernel_process_test_data_expected = rand;

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (cpu_id() + 1) % acpi_get_number_cpus();

    cpu_var(kernel_process_test_data, target) = rand;

    // Make the target cpu write down its percpu segment selector into
    // kernel_process_test_expected_gs.
    exec_remote_call(target,
                     remote_read_gs,
                     &kernel_process_test_expected_gs,
                     true);

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, kproc, false);

    while (!kernel_process_test_success) {
        cpu_pause();
    }

    init_aps();
    delete_proc(kproc);
    return true;
}

static bool create_proc_oom_test(void) {
    frame_alloc_set_oom_simulation(true);
    TEST_ASSERT(!create_proc());
    TEST_ASSERT(!create_kproc(NULL, NULL));
    frame_alloc_set_oom_simulation(false);
    CLEAR_ERROR();
    return true;
}

// When calling save_registers() from C code it is hard to predict the value of
// ESP and EFLAGS. For that reason, the ASM code actually calling save_registers
// will write the value of ESP and EFLAGS in the following variable just before
// the call.
reg_t save_registers_test_exp_esp;
reg_t save_registers_test_exp_eflags;

// Test the save_registers() function.
static bool save_registers_test(void) {

    // The test routine is written in ASM and will set all registers to some
    // values (except CS, DS, and SS), call save_registers() with the
    // destination passed as argument, restore the registers and return.
    extern void save_registers_test_routine(struct register_save_area *);

    struct register_save_area regs;
    save_registers_test_routine(&regs);

    TEST_ASSERT(regs.eax == 0xAAAAAAAA);
    TEST_ASSERT(regs.ebx == 0xBBBBBBBB);
    TEST_ASSERT(regs.ecx == 0xCCCCCCCC);
    TEST_ASSERT(regs.edx == 0xDDDDDDDD);
    TEST_ASSERT(regs.esi == 0xDEADBEEF);
    TEST_ASSERT(regs.edi == 0xBEEFBABE);
    TEST_ASSERT(regs.ebp == 0xDEADBABE);
    TEST_ASSERT(regs.esp == save_registers_test_exp_esp);

    TEST_ASSERT(regs.eip == 0xDEADC0DE);
    TEST_ASSERT(regs.eflags == save_registers_test_exp_eflags);
    
    union segment_selector_t const curr_gs = cpu_read_gs();
    TEST_ASSERT(regs.cs == kernel_code_selector().value);
    TEST_ASSERT(regs.ds == kernel_data_selector().value);
    TEST_ASSERT(regs.es == curr_gs.value);
    TEST_ASSERT(regs.fs == curr_gs.value);
    TEST_ASSERT(regs.gs == kernel_data_selector().value);
    TEST_ASSERT(regs.ss == kernel_data_selector().value);
    return true;
}

// This struct is used in multiple tests to check the values of registers in
// process' contexts.
struct proc_test_data {
    // If 1 then the process is done writting its registers into the `registers`
    // field below.
    uint32_t volatile flag;
    // Contains the values of all the registers as they appear in the process
    // once it is running. Only valid if flag is 1.
    struct register_save_area registers;
};

// Generate a "random" uint32_t using the TSC.
// @return: An arbitrary uint32_t.
static uint32_t poor_mans_rand(void) {
    uint64_t const tsc = read_tsc();
    return (uint32_t)tsc;
}

// Helper function used to set the saved registers of a process to some
// arbitrary values.
// @param proc: The proc to set the registers for.
// Note: Some of the registers CANNOT have arbitrary values, those are:
//  - EIP: Otherwise we would have a #PF when doing the iret to the process.
//  - ESP: The process will push onto its stack so the ESP must point onto its
//  stack.
//  - CS: Otherwise we would have a #PF when doing the iret to the process.
//  - SS: The process will push onto its stack, hence SS must be a valid segment
//  with correct privileges.
//  - For kernel proc: GS: This is because the GS will be set to point to the
//  percpu segment of the cpu running the process.
static void set_registers_for_test(struct proc * const proc) {
    proc->registers.eax = poor_mans_rand();
    proc->registers.ebx = poor_mans_rand();
    proc->registers.ecx = poor_mans_rand();
    proc->registers.edx = poor_mans_rand();
    proc->registers.esi = poor_mans_rand();
    proc->registers.edi = poor_mans_rand();
    proc->registers.ebp = poor_mans_rand();
    // For the EFLAGS, make sure the interrupts are enabled. The bit 1 MUST be
    // set as it is always 1 in x86. This is to avoid comparison failure.
    proc->registers.eflags = (1 << 9) | 0x2;

    // For segment registers, set user segments. This is because setting kernel
    // segments for user process will not work as IRET would zero them out. This
    // is a quirky behaviour of x86.
    uint32_t const ud = user_data_seg_sel().value;
    uint32_t const uc = user_data_seg_sel().value;
    proc->registers.es = poor_mans_rand() % 2 ? ud : uc;
    proc->registers.fs = poor_mans_rand() % 2 ? ud : uc;
    proc->registers.ds = poor_mans_rand() % 2 ? ud : uc;
    if (!proc->is_kernel_proc) {
        // For user processes, we can change GS.
        proc->registers.gs = poor_mans_rand() % 2 ? ud : uc;
    } else {
        // For kernel processes, the GS will be set to the percpu segment of the
        // cpu running it.
    }
}

// =============================================================================
// switch_to_proc() tests. In these tests we start execution of a process using
// switch_to_proc() and checks that the process starts with the correct values
// loaded into its registers (GPs, EFLAGS, and segment registers). This test is
// done for ring 0 and ring 3.

// Run the test for a certain ring.
// @param ring: The ring of the process to create and execute.
// @return: true if the test is successful, false otherwise.
static bool switch_to_proc_test(uint8_t const ring) {
    // This test runs as follows:
    //  1. The process is created.
    //  2. The process' registers (saved into the struct proc) are set to some
    //  values.
    //  3. A struct proc_test_data is pushed onto the process' stack (by this
    //  function, NOT the process itself) and initialized.
    //  4. The process is run and executes switch_to_proc_test_routine. This
    //  routine will copy the register values into the struct proc_test_data
    //  onto the stack.
    //  5. Wait for the process to indicate that it is done by waiting on the
    //  `flag` field of the struct proc_test_data.
    //  6. Compare the register values reported in the struct proc_test_data
    //  with the expected values.

    // This function is the code of the process. It expects the ESP register to
    // point to a struct proc_test_data onto the stack. This function will fill
    // the struct with the current values of its registers before writing 1 into
    // the `flag` field.
    extern void switch_to_proc_test_routine(void);

    struct proc * const p = create_test_proc(ring, switch_to_proc_test_routine);

    // The cpu on which the process will run.
    uint8_t const cpu = TEST_TARGET_CPU(0);

    // For kernel processes, the GS is set to the percpu segment of the cpu
    // running them. Since the process will run on a remote cpu, we need to know
    // the GS of this cpu for the comparison.
    union segment_selector_t target_gs;
    exec_remote_call(cpu, remote_read_gs, &target_gs, true);

    set_registers_for_test(p);
    if (p->is_kernel_proc) {
        p->registers.gs = target_gs.value;
    }
    
    // Since we are going to read/write into the process' stack, we need to
    // switch to its address space.
    switch_to_addr_space(p->addr_space);

    // Prepare the struct proc_test_data onto the process' stack.
    p->registers.esp -= sizeof(struct proc_test_data);
    struct proc_test_data * const data = (void*)p->registers.esp;
    memzero(data, sizeof(*data));

    // Execute proc on remote cpu.
    exec_remote_call(cpu, exec_proc, p, false);

    // Wait for proc to terminate execution.
    while (!data->flag) {
        lapic_sleep(50);
    }

    // Compare the values of the registers read by the process with the expected
    // values store into its struct proc.
    struct register_save_area const * const exp = &p->registers;
    struct register_save_area const * const curr = &data->registers;
    bool const same = memeq(exp, curr, sizeof(*exp));
    LOG("Comparison = %d\n", same);

    switch_to_addr_space(get_kernel_addr_space());

    init_aps();
    delete_proc(p);
    return same;
}

static bool switch_to_proc_test_ring0(void) {
    return switch_to_proc_test(0);
}

static bool switch_to_proc_test_ring3(void) {
    return switch_to_proc_test(3);
}

// =============================================================================
// interrupt_reg_save() test: This test will check two things:
//  - When a process is interrupted, the values of the registers reported in the
//  struct interrupt_frame should correspond to the value of the registers right
//  before the interrupt.
//  - When a process resumes execution after being interrupted, the values of
//  its registers should be the same as right before the interrupt (except for
//  EIP), provided that the handler does not change the values of the saved
//  registers.
//
// This test works as follows:
//  1. Create a process. A struct proc_test_data is pushed onto its stack and
//  ESP is pointing at it.
//  2. Set the saved registers of the process to some arbitrary values.
//  3. Run the process. The process will execute the interrupt_reg_save_routine
//  function which will execute the following:
//      i.  Execute a int 0x80.
//      ii. After returning from the interrupt save all the registers into the
//      struct proc_test_data present on the stack and set its flag to 1.
//  4. In the interrupt handler for vector 0x80, check that the registers
//  reported in the struct interrupt_frame are the same as the saved registers
//  of the struct proc of the process, except for EIP (see code). Return
//  immediately.
//  5. (On the cpu executing the test) Wait for the `flag` field to become 1 on
//  the process' stack.
//  6. Once `flag` is 1 (indicating that the process as copied its registers
//  into the struct proc_test_data onto its stack), check that the value of the
//  registers are the same as the saved values in struct proc.

// Set in the 0x80 handler to indicate if the comparison was successful.
static bool int_frame_has_correct_regs = false;
// Because the process will execute the `int 0x80` instruction, the EIP would
// have advanced at the time of the interrupt. Hence its expected value will be
// different than in the struct proc.
static reg_t int_frame_exp_eip = 0x0;
// The process used in this test.
struct proc * proc = NULL;

// Handler for the interrupt with vector 0x80.
static void int_reg_save_handler(struct interrupt_frame const * const frame) {
    LOG("Received SW interrupt 0x80 from process\n");

    if (frame->registers->eip != int_frame_exp_eip) {
        LOG("Disrepancy in EIP\n");
    } else {
        proc->registers.eip = int_frame_exp_eip; 
        struct register_save_area const * const exp = &proc->registers;
        struct register_save_area const * const curr = frame->registers;
        bool const same = memeq(exp, curr, sizeof(*exp));
        LOG("Comparison in interrupt = %d\n", same);
        int_frame_has_correct_regs = same;
    }
}

// Execute the interrupt_reg_save() test for a process in a given privilege
// ring.
// @param ring: The ring to use for the process.
// @return: true on sucess, false otherwise.
static bool interrupt_reg_save(uint8_t const ring) {
    // i.  Execute a int 0x80.
    // ii. After returning from the interrupt save all the registers into the
    //     struct proc_test_data present on the stack and set its flag to 1.
    extern void interrupt_reg_save_routine(void);

    // The address of the instruction after the INT 0x80 in
    // interrupt_reg_save_routine.
    extern uint8_t interrupt_reg_save_routine_after_int;

    interrupt_register_global_callback(SYSCALL_VECTOR, int_reg_save_handler);

    proc = create_test_proc(ring, interrupt_reg_save_routine);

    int_frame_has_correct_regs = false;
    // Compute the expected EIP to see within the interrupt handler.
    int_frame_exp_eip = proc->registers.eip +
        ((void*)&interrupt_reg_save_routine_after_int -
         (void*)&interrupt_reg_save_routine);

    // The cpu on which the process will run.
    uint8_t const cpu = TEST_TARGET_CPU(0);

    // For kernel processes, the GS is set to the percpu segment of the cpu
    // running them. Since the process will run on a remote cpu, we need to know
    // the GS of this cpu for the comparison.
    union segment_selector_t target_gs;
    exec_remote_call(cpu, remote_read_gs, &target_gs, true);

    set_registers_for_test(proc);
    if (proc->is_kernel_proc) {
        proc->registers.gs = target_gs.value;
    }

    // Since we are going to read/write into the process' stack, we need to
    // switch to its address space.
    switch_to_addr_space(proc->addr_space);

    // Prepare the struct proc_test_data onto the process' stack.
    proc->registers.esp -= sizeof(struct proc_test_data);
    struct proc_test_data * const data = (void*)proc->registers.esp;
    memzero(data, sizeof(*data));

    // Execute proc on remote cpu.
    exec_remote_call(cpu, exec_proc, proc, false);

    // Wait for proc to terminate execution.
    while (!data->flag) {
        lapic_sleep(50);
    }

    // Compare the values of the registers read by the process with the expected
    // values store into its struct proc.
    struct register_save_area const * const exp = &proc->registers;
    struct register_save_area const * const curr = &data->registers;
    bool const same = memeq(exp, curr, sizeof(*exp));
    LOG("Comparison = %d\n", same);

    switch_to_addr_space(get_kernel_addr_space());

    interrupt_delete_global_callback(SYSCALL_VECTOR);

    init_aps();
    delete_proc(proc);
    return same;
}

static bool interrupt_reg_save_test_ring0(void) {
    return interrupt_reg_save(0);
}

static bool interrupt_reg_save_test_ring3(void) {
    return interrupt_reg_save(3);
}

void proc_test(void) {
    TEST_FWK_RUN(get_stack_bottom_test);
    TEST_FWK_RUN(create_proc_test);
    TEST_FWK_RUN(create_kproc_test);
    TEST_FWK_RUN(privileged_instr_in_ring3_test);
    TEST_FWK_RUN(kernel_access_from_ring3_test);
    TEST_FWK_RUN(kernel_process_test);
    TEST_FWK_RUN(create_proc_oom_test);
    TEST_FWK_RUN(save_registers_test);
    TEST_FWK_RUN(switch_to_proc_test_ring0);
    TEST_FWK_RUN(switch_to_proc_test_ring3);
    TEST_FWK_RUN(interrupt_reg_save_test_ring0);
    TEST_FWK_RUN(interrupt_reg_save_test_ring3);
}
