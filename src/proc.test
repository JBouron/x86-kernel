#include <test.h>
#include <acpi.h>
#include <ipm.h>
#include <proc_test_helpers.h>

static bool get_stack_bottom_test(void) {
    void const * const stack_top = 0x0;
    uint32_t const stack_size = 1;
    TEST_ASSERT(get_stack_bottom(stack_top, stack_size) == (void*)0xFFC);
    return true;
}

static bool create_proc_test(void) {
    struct proc * const proc = create_proc();

    // Check that registers are initialized correctly.
    TEST_ASSERT(proc->registers_save.edi == 0);
    TEST_ASSERT(proc->registers_save.esi == 0);
    TEST_ASSERT(proc->registers_save.ebp == (reg_t)proc->user_stack.bottom);
    TEST_ASSERT(proc->registers_save.ebx == 0);
    TEST_ASSERT(proc->registers_save.edx == 0);
    TEST_ASSERT(proc->registers_save.ecx == 0);
    TEST_ASSERT(proc->registers_save.eax == 0);
    TEST_ASSERT(proc->registers_save.eip == 0);
    TEST_ASSERT(proc->registers_save.eflags == 1 << 9);
    TEST_ASSERT(proc->registers_save.esp == (reg_t)(proc->user_stack.bottom));

    delete_proc(proc);
    return true;
}

static bool create_kproc_test(void) {
    struct proc * const proc = create_kproc((void*)0xDEADBEEF, (void*)0xABCDEF);

    // Check that registers are initialized correctly.
    TEST_ASSERT(proc->registers_save.edi == 0);
    TEST_ASSERT(proc->registers_save.esi == 0);
    TEST_ASSERT(proc->registers_save.ebp == (reg_t)proc->kernel_stack.bottom);
    TEST_ASSERT(proc->registers_save.ebx == 0);
    TEST_ASSERT(proc->registers_save.edx == 0);
    TEST_ASSERT(proc->registers_save.ecx == 0);
    TEST_ASSERT(proc->registers_save.eax == 0);
    TEST_ASSERT(proc->registers_save.eip == 0);
    TEST_ASSERT(proc->registers_save.eflags == 1 << 9);

    delete_proc(proc);
    return true;
}

// Tries to execute a privileged instruction.
extern void privileged_instr_in_ring3_code(void);

static bool volatile privileged_instr_in_ring3_gp_raised = false;
static reg_t privileged_instr_in_ring3_expected_eip = 0;
static void privileged_instr_in_ring3_gp_handler(
    struct interrupt_frame const * const frame) {

    LOG("General protection fault recieved on cpu %u\n", this_cpu_var(cpu_id));

    // Check that the EIP points to the correct instruction and that the
    // original CS was user code segment.
    privileged_instr_in_ring3_gp_raised =
        frame->registers->eip == privileged_instr_in_ring3_expected_eip &&
        frame->registers->cs == user_code_seg_sel().value;

    // Wait for the cpu running the test to re-init this cpu.
    lock_up();
}

static bool privileged_instr_in_ring3_test(void) {
    struct proc * const proc = create_proc();

    extern uint8_t privileged_instr_in_ring3_code_start;
    extern uint8_t privileged_instr_in_ring3_code_end;
    size_t const len = &privileged_instr_in_ring3_code_end -
        &privileged_instr_in_ring3_code_start;
    void const * const code = privileged_instr_in_ring3_code;

    copy_code_to_proc(proc, code, len);
    // The very first instruction should be the one raising the #GP.
    privileged_instr_in_ring3_expected_eip = proc->registers_save.eip;

    // Vector for a General Protection Fault.
    uint8_t const v = 13;
    interrupt_register_global_callback(v, privileged_instr_in_ring3_gp_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (this_cpu_var(cpu_id) + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, proc, false);

    // The process running in ring 3 will try to execute the cli instruction
    // which is a privileged instruction. Therefore a general protection fault
    // should be raise. The privileged_instr_in_ring3_gp_handler() will set the
    // privileged_instr_in_ring3_gp_raised bit to true when that happens.
    while (!privileged_instr_in_ring3_gp_raised) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();

    interrupt_delete_global_callback(v);
    delete_proc(proc);
    return true;
}

static uint8_t register_saving_ring3_int_syscall_count = 0;
static bool register_saving_ring3_int_syscall_success = false;
static void register_saving_ring3_int_syscall_handler(
    struct interrupt_frame const * const frame) {

    register_saving_ring3_int_syscall_count ++; 
    if (register_saving_ring3_int_syscall_count == 1) {
        // This is the first syscall, nothing to do here, we return to the
        // process execution.
        LOG("First interrupt for register_saving_ring3_int_test.\n");
    } else if (register_saving_ring3_int_syscall_count == 2) {
        // In the second interrupt, the process will put the result of the
        // comparison in its EAX register.
        LOG("Second interrupt for register_saving_ring3_int_test.\n");
        LOG("EAX = %u\n", frame->registers->eax);

        register_saving_ring3_int_syscall_success = frame->registers->eax == 1;
        // Wait for the cpu running the test to re-init this cpu.
        lock_up();
    }
}

extern void register_saving_ring3_int_code(void);

static bool register_saving_ring3_int_test(void) {
    struct proc * const proc = create_proc();

    extern uint8_t register_saving_ring3_int_code_start;
    extern uint8_t register_saving_ring3_int_code_end;
    size_t const len = &register_saving_ring3_int_code_end -
        &register_saving_ring3_int_code_start;
    void const * const code = register_saving_ring3_int_code;

    copy_code_to_proc(proc, code, len);

    interrupt_register_global_callback(SYSCALL_VECTOR,
        register_saving_ring3_int_syscall_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (this_cpu_var(cpu_id) + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, proc, false);

    while (!register_saving_ring3_int_syscall_success) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();
    interrupt_delete_global_callback(SYSCALL_VECTOR);
    delete_proc(proc);
    return true;
}

extern void kernel_access_from_ring3_code(void);

static reg_t kernel_access_from_ring3_expected_eip = 0;
uint32_t kernel_access_from_ring3_kernel_var = 0xDEADBEEF;
static bool kernel_access_from_ring3_pg_ok = false;

static void kernel_access_from_ring3_pg_handler(
    struct interrupt_frame const * const frame) {
    LOG("Page fault from ring 3\n");
    LOG("Error Code = %x\n", frame->error_code);
    bool success = true;
    success &= frame->registers->cs == user_code_seg_sel().value;
    success &= frame->registers->eip == kernel_access_from_ring3_expected_eip;
    success &= cpu_read_cr2() == &kernel_access_from_ring3_kernel_var;
    // The error code should have the following bits set: User-mode access,
    // Write, Page-level protection violation.
    success &= frame->error_code == ((1 << 2) | (1 << 1) | 1);
    kernel_access_from_ring3_pg_ok = success;

    lock_up();
}

// Test that a process running in ring 3 gets a page fault when trying to access
// kernel data.
static bool kernel_access_from_ring3_test(void) {
    struct proc * const proc = create_proc();

    extern uint8_t kernel_access_from_ring3_code_start;
    extern uint8_t kernel_access_from_ring3_code_end;
    size_t const len = &kernel_access_from_ring3_code_end -
        &kernel_access_from_ring3_code_start;
    void const * const code = kernel_access_from_ring3_code;

    copy_code_to_proc(proc, code, len);

    kernel_access_from_ring3_expected_eip = proc->registers_save.eip;

    interrupt_register_global_callback(14, kernel_access_from_ring3_pg_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (this_cpu_var(cpu_id) + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, proc, false);

    while (!kernel_access_from_ring3_pg_ok) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();
    interrupt_delete_global_callback(14);
    delete_proc(proc);
    return true;
}

// This percpu variable is used by the kernel process to make sure that it can
// access the percpu variables.
DECLARE_PER_CPU(uint64_t, kernel_process_test_data);
static uint64_t kernel_process_test_data_expected = 0;
static uint16_t kernel_process_test_expected_gs = 0;
static bool volatile kernel_process_test_success = false;
static void * kernel_process_expected_arg = NULL;

static void kernel_process_code(void * arg) {
    LOG("[%u] Kernel process is running kernel code.\n", this_cpu_var(cpu_id));
    bool success = true;

    // Check that the correct arg was passed onto the stack.
    success &= arg == kernel_process_expected_arg;

    // Make sure we are in ring 0.
    success &= cpu_read_cs().value == kernel_code_selector().value;
    success &= cpu_read_ds().value == kernel_data_selector().value;
    success &= cpu_read_fs().value == kernel_data_selector().value;
    success &= cpu_read_es().value == kernel_data_selector().value;
    success &= cpu_read_ss().value == kernel_data_selector().value;
    success &= cpu_read_gs().value == kernel_process_test_expected_gs;

    // Try to access the cpu vars.
    success &= this_cpu_var(kernel_process_test_data) ==
        kernel_process_test_data_expected;

    // Try to execute some privileged instructions.
    cpu_set_interrupt_flag(false);
    cpu_set_interrupt_flag(true);

    kernel_process_test_success = success;

    // Wait to be reset.
    lock_up();
}

static void remote_read_gs(void * arg) {
    ASSERT(percpu_initialized());
    uint16_t const expected_gs = cpu_read_gs().value;
    LOG("[%u] Expected GS = %x\n", this_cpu_var(cpu_id), expected_gs);
    *(uint16_t*)arg = expected_gs;
}

static bool kernel_process_test(void) {
    void * const arg = (void*)0xDEADBABE;
    kernel_process_expected_arg = arg;

    struct proc * const kproc = create_kproc(kernel_process_code, arg);

    uint64_t const rand = read_tsc();
    kernel_process_test_data_expected = rand;

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (this_cpu_var(cpu_id) + 1) % acpi_get_number_cpus();

    cpu_var(kernel_process_test_data, target) = rand;

    // Make the target cpu write down its percpu segment selector into
    // kernel_process_test_expected_gs.
    exec_remote_call(target,
                     remote_read_gs,
                     &kernel_process_test_expected_gs,
                     true);

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, kproc, false);

    while (!kernel_process_test_success) {
        cpu_pause();
    }

    init_aps();
    delete_proc(kproc);
    return true;
}

static uint8_t register_saving_ring0_int_syscall_count = 0;
static bool register_saving_ring0_int_syscall_success = false;
static void register_saving_ring0_int_syscall_handler(
    struct interrupt_frame const * const frame) {

    register_saving_ring0_int_syscall_count ++; 
    if (register_saving_ring0_int_syscall_count == 1) {
        // This is the first syscall, nothing to do here, we return to the
        // process execution.
        LOG("First interrupt for register_saving_ring0_int_test.\n");
    } else if (register_saving_ring0_int_syscall_count == 2) {
        // In the second interrupt, the process will put the result of the
        // comparison in its EAX register.
        LOG("Second interrupt for register_saving_ring0_int_test.\n");
        LOG("EAX = %u\n", frame->registers->eax);

        register_saving_ring0_int_syscall_success = frame->registers->eax == 1;
        // Wait for the cpu running the test to re-init this cpu.
        lock_up();
    }
}

static bool register_saving_ring0_int_test(void) {
    // Re-use the register_saving_ring3_int_code function.
    void *func = (void*)&register_saving_ring3_int_code;
    struct proc * const kproc = create_kproc(func, NULL);

    interrupt_register_global_callback(SYSCALL_VECTOR,
        register_saving_ring0_int_syscall_handler);

    TEST_ASSERT(acpi_get_number_cpus() > 1);
    uint8_t const target = (this_cpu_var(cpu_id) + 1) % acpi_get_number_cpus();

    // make the other cpu execute the process. we cannot wait since the
    // exec_proc function does not return.
    exec_remote_call(target, exec_proc, kproc, false);

    while (!register_saving_ring0_int_syscall_success) {
        cpu_pause();
    }

    // The remote cpu is stuck executing the process. Unstuck it by
    // re-initializing it.
    init_aps();
    interrupt_delete_global_callback(SYSCALL_VECTOR);
    delete_proc(kproc);
    return true;
}

static bool create_proc_oom_test(void) {
    frame_alloc_set_oom_simulation(true);
    TEST_ASSERT(!create_proc());
    TEST_ASSERT(!create_kproc(NULL, NULL));
    frame_alloc_set_oom_simulation(false);
    CLEAR_ERROR();
    return true;
}

void proc_test(void) {
    TEST_FWK_RUN(get_stack_bottom_test);
    TEST_FWK_RUN(create_proc_test);
    TEST_FWK_RUN(create_kproc_test);
    TEST_FWK_RUN(privileged_instr_in_ring3_test);
    TEST_FWK_RUN(register_saving_ring3_int_test);
    TEST_FWK_RUN(kernel_access_from_ring3_test);
    TEST_FWK_RUN(kernel_process_test);
    TEST_FWK_RUN(register_saving_ring0_int_test);
    TEST_FWK_RUN(create_proc_oom_test);
}
