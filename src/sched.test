#include <test.h>
#include <ipm.h>
#include <smp.h>

// Helper function to cancel the effect of a sched_init() call. More
// specifically, this function will delete the idle processes created in
// sched_init(). Additionally, it will make sure that the curr_proc of all cpu
// is set to NULL.
static void sched_cancel_init(void) {
    for (uint16_t cpu = 0; cpu < acpi_get_number_cpus(); ++cpu) {
        struct proc * const idle = cpu_var(idle_proc, cpu);
        ASSERT(idle);
        delete_proc(idle);
        cpu_var(curr_proc, cpu) = NULL;
    } 
}

// ============================================================================= 
// Tests for the functions in sched_core responsible to call the correct
// callbacks. More specifically:
//  - sched_init() should call the `sched_init` callback.
//  - sched_enqueue() should call the `enqueue_proc` callback.
//  - sched_dequeue() should call the `dequeue_proc` callback.
//  - sched_update_curr() should call the `update_curr` callback.
//  - sched_tick() should call the `tick` callback.
// sched_core.c does not provide wrappers for `pick_next_proc` and
// `put_prev_proc`, those are called in schedule(). Hence those are not tested
// here but will be tested in the schedule() test.

enum callback_id {
    NONE, INIT, ENQUEUE, DEQUEUE, UPDATE_CURR, TICK, PICK_NEXT, PUT_PREV,
};

// Indicate the last callback that was called.
static enum callback_id ct_last_callback = NONE;
// Indicate the value of the struct proc pass as argument in the last callback
// if applicable.
static struct proc * ct_last_proc = NULL;

static void ct_sched_init(void) {
    ASSERT(ct_last_callback == NONE);
    ct_last_callback = INIT;
}

static void ct_enqueue_proc(struct proc * const proc) {
    ASSERT(ct_last_callback == NONE);
    ct_last_callback = ENQUEUE;
    ct_last_proc = proc;
}

static void ct_dequeue_proc(struct proc * const proc) {
    ASSERT(ct_last_callback == NONE);
    ct_last_callback = DEQUEUE;
    ct_last_proc = proc;
}

static void ct_update_curr(void) {
    ASSERT(ct_last_callback == NONE);
    ct_last_callback = UPDATE_CURR;
}

static void ct_tick(void) {
    ASSERT(ct_last_callback == NONE);
    ct_last_callback = TICK;
}

static struct sched callbacks_test_sched = {
    .sched_init       = ct_sched_init,
    .enqueue_proc     = ct_enqueue_proc,
    .dequeue_proc     = ct_dequeue_proc,
    .update_curr      = ct_update_curr,
    .tick             = ct_tick,
    .pick_next_proc   = NULL,
    .put_prev_proc    = NULL,
};

static bool sched_callbacks_test(void) {
    struct sched * const old_sched = SCHEDULER;
    SCHEDULER = &callbacks_test_sched;   

    // Create a placeholder process. It won't be executed but it needs to be
    // runnable (since we will enqueue it).
    struct proc * const proc = create_kproc(NULL, NULL);

    // Test that the callbacks are called when calling sched_core.c's wrapper
    // functions.
    sched_init();
    TEST_ASSERT(ct_last_callback == INIT);
    ct_last_callback = NONE;
    ct_last_proc = NULL;

    sched_enqueue_proc(proc);
    TEST_ASSERT(ct_last_callback == ENQUEUE);
    TEST_ASSERT(ct_last_proc == proc);
    ct_last_callback = NONE;
    ct_last_proc = NULL;

    // We need to mock the fact that the cpu is running the process.
    this_cpu_var(curr_proc) = proc;
    sched_update_curr();
    TEST_ASSERT(ct_last_callback == UPDATE_CURR);
    ct_last_callback = NONE;
    ct_last_proc = NULL;

    sched_tick(NULL);
    TEST_ASSERT(ct_last_callback == TICK);
    ct_last_callback = NONE;
    ct_last_proc = NULL;

    sched_dequeue_proc(proc);
    TEST_ASSERT(ct_last_callback == DEQUEUE);
    TEST_ASSERT(ct_last_proc == proc);
    ct_last_callback = NONE;
    ct_last_proc = NULL;

    delete_proc(proc);
    sched_cancel_init();
    SCHEDULER = old_sched;
    return true;
}

void sched_test(void) {
    TEST_FWK_RUN(sched_callbacks_test);
}
