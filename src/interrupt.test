#include <test.h>
#include <proc.h>

// Test the init_desc function.
static bool interrupt_test_init_desc(void) {
    union interrupt_descriptor_t desc;
    uint32_t const offset = 0xDEADBEEF;
    union segment_selector_t const sel = { .value = 0xBABE };
    uint8_t const priv_level = 2;

    init_desc(&desc, offset, sel, priv_level);
    
    uint32_t const encoded_offset = (desc.offset_31_16 << 16) |
        desc.offset_15_0;
    TEST_ASSERT(encoded_offset == offset);
    TEST_ASSERT(desc.segment_selector == sel.value);
    TEST_ASSERT(desc.reserved == 0);
    TEST_ASSERT(desc.zero == 0);
    TEST_ASSERT(desc.six == 6);
    TEST_ASSERT(desc.size == 1);
    TEST_ASSERT(desc.zero2 == 0);
    TEST_ASSERT(desc.privilege_level == priv_level);
    TEST_ASSERT(desc.present == 1);

    return true;
}

// Make sure that the get_interrupt_handler helper function returns the correct
// offset for a given vector.
extern uint8_t interrupt_handler_0;
extern uint8_t interrupt_handler_5;
extern uint8_t interrupt_handler_13;
static bool get_interrupt_handler_test(void) {
    uint32_t const handler_0_offset = get_interrupt_handler(0);
    uint32_t const handler_5_offset = get_interrupt_handler(5);
    uint32_t const handler_13_offset = get_interrupt_handler(13);
    TEST_ASSERT(handler_0_offset ==
        (uint32_t)&interrupt_handler_0);
    TEST_ASSERT(handler_5_offset ==
        (uint32_t)&interrupt_handler_5);
    TEST_ASSERT(handler_13_offset == 
        (uint32_t)&interrupt_handler_13);
    return true;
}

// The following test is an end-to-end interrupt test. The goal here is to
// register an interrupt handler, trigger the corresponding interrupt, and check
// that the interrupt handler has been called.
// To this end we choose to use interrupt 0. We register the handler
// basic_interrupt_test_handler for it. This handler will mutate the
// basic_interrupt_test_target global (initially 0) to a specific value (0xAA).
// The test runs as follows:
//   1. Register the interrupt handler for int 0 by using a fake IDT.
//   2. Trigger the interrupt 0.
//   3. Check that basic_interrupt_test_target is 0xAA.

// Helper function to trigger the interrupt.
extern void basic_interrupt_test_int(void);
// Interrupt handler to be used for interrupt 0.
extern void basic_interrupt_test_handler(void);
// The target that the interrupt handler will mutate to indicate success.
uint8_t basic_interrupt_test_target = 0;

// The actual test.
static bool basic_interrupt_test(void) {
    // Save original IDTR.
    struct idt_desc orig_idtr;
    cpu_sidt(&orig_idtr);

    // Create a fake IDT.
    union interrupt_descriptor_t fake_idt[1];
    // Make the first offset in the IDT point to basic_interrupt_test_handler.
    uint32_t const offset = (uint32_t)&basic_interrupt_test_handler;
    init_desc(fake_idt, offset, kernel_code_selector(), 0);
    // Load the fake IDT.
    struct idt_desc const desc = {
        .base = fake_idt,
        .limit = (sizeof(fake_idt) - 1),
    };

    // Make sure to disable the interrupts when loading the new IDT.
    cpu_set_interrupt_flag(false);
    cpu_lidt(&desc);

    // Make sure to reset the target.
    basic_interrupt_test_target = 0;

    // We do not need to enable the interrupts as we are using a software
    // interrupt.

    // Trigger the interrupt.
    basic_interrupt_test_int();

    // Restore IDTR.
    cpu_lidt(&orig_idtr);

    // Make sure that the handler has been called.
    return basic_interrupt_test_target == 0xAA;
}

// Test the callback mechanism of interrupts.
// Register a callback for the vector 0. This callback sets `callback_target` to
// 0xBB.
// The test runs as follows:
// 1. Register the callback.
// 2. Raise a software interrupt with vector 0.
// 3. Check that callback_target is 0xBB.
static uint8_t callback_target = 0x0;
// callback_cond holds the following truth statment from the callback:
//   vector == 0 AND cs == kernel cs.
static bool callback_conds = false;
static void test_callback(struct interrupt_frame const * const frame) {
    callback_conds = frame->vector == 0 &&
        frame->cs == kernel_code_selector().value;
    callback_target = 0xBB;
}

static bool interrupt_register_callback_test(void) {
    interrupt_register_local_callback(0, test_callback);
    basic_interrupt_test_int();

    // remove the callback from the callback array.
    interrupt_delete_local_callback(0);
    return callback_target == 0xBB && callback_conds;
}

static bool global_callback_called = false;
static void global_callback(struct interrupt_frame const * const frame) {
    ASSERT(frame);
    global_callback_called = true;
}

static bool local_callback_called = false;
static void local_callback(struct interrupt_frame const * const frame) {
    ASSERT(frame);
    local_callback_called = true;
}

// Check that a local callback has the priority over a global callback.
static bool interrupt_local_callback_priority_test(void) {
    interrupt_register_global_callback(0, global_callback);
    interrupt_register_local_callback(0, local_callback);
    basic_interrupt_test_int();
    interrupt_delete_global_callback(0);
    interrupt_delete_local_callback(0);
    return !global_callback_called && local_callback_called;
}

// Do a software interrupt with vector = 0 (any vector works as long as it does
// not have an error code). This function will put specific values in registers
// and store the expected values in interrupt_register_save_expected.
extern bool interrupt_register_save_do_int(void);
struct register_save_area interrupt_register_save_expected;
static bool interrupt_register_save_success = false;
static void interrupt_register_save_handler(
    struct interrupt_frame const * const frame) {

    bool success = true;
    success &= (frame->registers->edi == interrupt_register_save_expected.edi);
    success &= (frame->registers->esi == interrupt_register_save_expected.esi);
    success &= (frame->registers->ebp == interrupt_register_save_expected.ebp);
    success &= (frame->registers->esp == interrupt_register_save_expected.esp);
    success &= (frame->registers->ebx == interrupt_register_save_expected.ebx);
    success &= (frame->registers->edx == interrupt_register_save_expected.edx);
    success &= (frame->registers->ecx == interrupt_register_save_expected.ecx);
    success &= (frame->registers->eax == interrupt_register_save_expected.eax);
    success &= 
        (frame->registers->eflags == interrupt_register_save_expected.eflags);
    success &= (frame->registers->eip == interrupt_register_save_expected.eip);
    success &= (frame->registers->gs == interrupt_register_save_expected.gs);
    success &= (frame->registers->fs == interrupt_register_save_expected.fs);
    success &= (frame->registers->ds == interrupt_register_save_expected.ds);
    success &= (frame->registers->ss == interrupt_register_save_expected.ss);
    success &= (frame->registers->cs == interrupt_register_save_expected.cs);
    success &= (frame->registers->es == interrupt_register_save_expected.es);

    interrupt_register_save_success = success;
}
static bool interrupt_register_save_test(void) {
    uint8_t const vector = 0;
    interrupt_register_local_callback(vector, interrupt_register_save_handler);

    interrupt_register_save_success = false;

    interrupt_register_save_do_int();

    return interrupt_register_save_success;
}

void interrupt_test(void) {
    TEST_FWK_RUN(interrupt_test_init_desc);
    TEST_FWK_RUN(get_interrupt_handler_test);
    TEST_FWK_RUN(basic_interrupt_test);
    TEST_FWK_RUN(interrupt_register_callback_test);
    TEST_FWK_RUN(interrupt_local_callback_priority_test);
    TEST_FWK_RUN(interrupt_register_save_test);
}
